\section{2-SAT~\small(ct)}
    \myminted{cpp}{graph_theory/2_sat.cpp}

\section{割点与桥~\small(ct)}
    \subsection*{割点}
        \myminted{cpp}{graph_theory/cut_point.cpp}
    \subsection*{桥}
        \myminted{cpp}{graph_theory/bridge.cpp}

\section{Steiner~tree~\small(lhy)}
    \myminted{cpp}{graph_theory/steiner_tree.cpp}

\section{K短路~\small(lhy)}
    \myminted{cpp}{graph_theory/kth_minimum_path.cpp}

\section{最大团~\small(Nightfall)}
    时间复杂度建议$ n \leq 150 $
    \myminted{cpp}{graph_theory/maximum_clique.cpp}

\section{极大团计数~\small(Nightfall)}
    $ 0 $-based, 需删除自环
    \\极大团计数, 最坏情况$ O(3^{n / 3}) $
    \myminted{cpp}{graph_theory/maximum_clique_count.cpp}

\section{三元环计数~\small(cxy)}
    \myminted{cpp}{graph_theory/ternary_ring.cpp}

\section{二分图最大匹配~\small(lhy)}
    左侧$ n $个点，右侧$ m $个点，$ 1 $-based，初始化将$ matx $和$ maty $置为$ 0 $
    \myminted{cpp}{graph_theory/hopcroft_karp.cpp}

\section{一般图最大匹配~\small(lhy)}
    \myminted{cpp}{graph_theory/blossom.cpp}

\section{KM算法~\small(Nightfall)}
    $ O(n^3) $，$ 1 $-based，最大权匹配
    \\不存在的边权值开到$ -n \times (\left| MAXV \right|) $，$ \infty $为$ 3 n \times (\left| MAXV \right|) $
    \\匹配为$ (lk_i, i) $
    \myminted{cpp}{graph_theory/km.cpp}

\section{最小树形图~\small(Nightfall)}
    \myminted{cpp}{graph_theory/zhu_liu.cpp}

\section{支配树~\small(ct,Nightfall)}
    \subsection*{DAG~\small(ct)}
        \myminted{cpp}{graph_theory/dominator_tree_dag.cpp}
    \subsection*{一般图~\small(Nightfall)}
        \myminted{cpp}{graph_theory/dominator_tree.cpp}

\section{虚树~\small(ct)}
    \myminted{cpp}{graph_theory/virtual_tree.cpp}

\section{点分治~\small(ct)}
    \myminted{cpp}{graph_theory/divide_conquer_on_tree.cpp}

\section{树上倍增~\small(ct)}
    \myminted{cpp}{graph_theory/multiplier_on_tree.cpp}

\section{树哈希~\small(lhy,Luna)}
    \subsection*{简易版~\small(lhy)}
        每个节点的哈希值为每个子树哈希值的三次方和$ + 1 $
    \subsection*{高级版~\small(Luna)}
        \noindent $A_i$表示以$i$为根的子树的哈希值\\
        $B_i$表示整棵树以$i$为根的哈希值
        \myminted{cpp}{graph_theory/tree_hash.cpp}

\section{Link-Cut~Tree~\small(ct)}
    LCT常见应用
    \begin{itemize}[nosep, wide=0pt]
        \item \textbf{动态维护边双}
            \\可以通过LCT来解决一类动态边双连通分量问题。即静态的询问可以用边双连通分量来解决，而树有加边等操作的问题。
            \\把一个边双连通分量缩到LCT的一个点中，然后在LCT上求出答案。缩点的方法为加边时判断两点的连通性，如果已经联通则把两点在目前LCT路径上的点都缩成一个点。
        \item \textbf{动态维护基环森林}
            \\通过LCT可以动态维护基环森林，即每个点有且仅有一个出度的图。有修改操作，即改变某个点的出边。对于每颗基环森林记录
            一个点为根，并把环上额外的一条边单独记出，剩下的边用LCT维护。一般使用有向LCT维护。
            \\修改时分以下几种情况讨论：
            \begin{itemize}[wide=0pt]
                \item 修改的点是根，如果改的父亲在同一个连通块中，直接改额外边，否则删去额外边，在LCT上加边。
                \item 修改的点不是根，那么把这个点和其父亲的联系切除。如果该点和根在一个环上，那么把多的那条边加到LCT上。最后如果改的那个父亲和修改的点在一个联通块中，记录额外边，否则LCT上加边。
            \end{itemize}
        \item \textbf{子树询问}
            \\通过记录轻边信息可以快速地维护出整颗LCT的一些值。如子树和，子树最大值等。在Access时要进行虚实边切换，这时减去实边的贡献，并加上新加虚边的贡献即可。有时需要套用数据结构，如Set来维护最值等问题。
            \\模板：
            \begin{itemize}[wide=0pt]
                \item $ x \to y $链$ + z $
                \item $ x \to y $链变为$ z $
                \item 在以$ x $为根的树对$ y $子树的点权求和
                \item $ x \to y $链取$ \max $
                \item $ x \to y $链求和
                \item 连接$ x, y $
                \item 断开$ x, y $
            \end{itemize}
            $ V $单点值，$ sz $平衡树的size，$ mv $链上最大，$ S $链上和，$ sm $区间相同标记，$ lz $区间加标记，$ B $虚边之和，$ ST $子树信息和，$ SM $子树和链上信息和。更新时：
            \\$ S[x] = S[c[x][0]] + S[c[x][1]] + V[x] $
            \\$ ST[x] =B[x] + ST[c[x][0]] + ST[c[x][1]] $
            \\$ SM[x] = S[x] + ST[x] $
    \end{itemize}
    \myminted{cpp}{graph_theory/link_cut_tree.cpp}

\section{圆方树~\small(ct)}
    \myminted{cpp}{graph_theory/circle_square_tree.cpp}

\section{无向图最小割~\small(Nightfall)}
    \myminted{cpp}{graph_theory/stoer_wagner.cpp}

\section{网络流~\small(lhy,ct)}
    \subsection*{Dinic~\small(ct)}
        \myminted{cpp}{graph_theory/dinic.cpp}
    \subsection*{SAP~\small(lhy)}
        \myminted{cpp}{graph_theory/sap.cpp}
    \subsection*{zkw费用流~\small(lhy)}
        \myminted{cpp}{graph_theory/zkw_min_cost_flow.cpp}

\section{欧拉回路~\small(cxy)}
    \subsection*{有向图欧拉回路 无向图欧拉回路}
        \myminted{cpp}{graph_theory/eular_circuit.cpp}
    \subsection*{混合图欧拉回路}
        将无向边任意定向，随后对每个点计算权值$ \frac{1}{2}| \text{入度} - \text{出度} |$，如果$ \text{入度} < \text{出度} $，从$ S $向该点连接一条流量为该点权值的边，如果$ \text{入度} > \text{出度} $，从该点向$ T $连接一条流量为该点权值的，随后将所有无向边按照之前所定方向连接一条流量为$ 1 $的边，随后跑最大流。如果两边的边都满流，则混合图欧拉回路有解，只需将中间满流的边反向，跑有向图欧拉回路即可

\section{图论知识~\small(gy,lhy)}
    \input{graph_theory/tex.tex}
